java成长笔记5
 19. 数据库
  19.1.1. 存储引擎
 19.1.1.2. InnoDB（B+树）
  InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，
  一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。
 适用场景：
1）经常更新的表，适合处理多重并发的更新请求。
2）支持事务。
3）可以从灾难中恢复（通过 bin-log 日志等）。
4）外键约束。只有他支持外键。
5）支持自动增加列属性 auto_increment。

 19.1.1.3. TokuDB（Fractal Tree-节点带数据）
   TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree
  中，每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个
  Message Buffer 是一个 FIFO 的队列，用来缓存更新操作
 
  例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶
 子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中
 TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优
势。 他主要适用于访问频率不高的数据或历史数据归档

 19.1.1.4. MyIASM
   MyIASM是 MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，
  因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。
  ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织
  成有固定长度的记录，按顺序存储的。---ISAM 是一种静态索引结构。
 19.1.1.5. Memory
   Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应
 一个磁盘文件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用
 HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉
  Memory 同时支持散列索引和 B 树索
 引，B树索引可以使用部分查询和通配查询，也可以使用<,>和>=等操作符方便数据挖掘，散列索
 引相等的比较快但是对于范围的比较慢很多
 19.1.2. 索引
  索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二
 叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree）
19.1.2.1. 常见索引原则有
 1.选择唯一性索引
  1．唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。
  2.为经常需要排序、分组和联合操作的字段建立索引：
  3．为常作为查询条件的字段建立索引。 
  4．限制索引的数目：越多的索引，会使更新表变得很浪费时间
 尽量使用数据量少的索引
 6．如果索引的值很长，那么查询的速度会受到影响。
 6．如果索引的值很长，那么查询的速度会受到影响。
 尽量使用前缀来索引
 7．如果索引字段的值很长，最好使用值的前缀来索引
 7．删除不再使用或者很少使用的索引
 8 . 最左前缀匹配原则，非常重要的原则。
 10 . 尽量选择区分度高的列作为索引
 区分度的公式是表示字段不重复的比例
 11 .索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。
 12 .尽量的扩展索引，不要新建索引。
 19.1.3. 数据库三范式
 19.1.3.1. 第一范式(1st NF －列都是不可再分)
 19.1.3.2. 第二范式(2nd NF－每个表只描述一件事情)
 19.1.3.3. 第三范式(3rd NF－ 不存在对非主键列的传递依赖)
19.1.4. 数据库是事务
 事务是一个不可分割的工作逻辑单元-ACID
 原子性（Atomicity）一致性（Consistency）隔离性（Isolation）永久性（Durability）
 19.1.5. 存储过程(特定功能的 SQL 语句集)
 一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次
 编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过
 程是数据库中的一个重要对象
19.1.6. 触发器(一段能自动执行的程序)
 触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：
 触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统
 会自动调用执行该表上对应的触发器
19.1.7. 数据库并发策略
 并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳
19.1.7.1. 乐观锁
 乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自
 己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间
 戳就是不加锁，通过时间戳来控制并发出现的问题。
19.1.7.2. 悲观锁
 悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加
 锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数
 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允
 许其他用户访问那部分数据。
19.1.7.3. 时间戳
  时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字
 段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数
 据库的值大的话，就允许保存，否则不允许保存-大大提高数据库处理的并发量
19.1.8. 数据库锁
 19.1.8.1. 行级锁-行级锁是一种排他锁，防止其他事务修改此行
  在使用以下语句时，Oracle 会自动应用行级锁：
  1. INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];
  2. SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新
  3. 使用 COMMIT 或 ROLLBACK 语句释放锁。
 19.1.8.2. 表级锁
   表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使
  用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁
  （排他锁）。
 19.1.8.1. 页级锁
   页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级
  冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁
 19.1.9. 基于 Redis 分布式锁-获取锁的时候，使用 setnx
 SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1
 若 key 存在，则什么都不做，返回 0
 加锁，锁的 value
 值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添
 加一个超时时间，超过该时间则自动释放锁
 -- 0-别人正在使用，1-获取到锁，设置过期时间，uuid判断是否该锁
19.1.10. 分区分表
 分库分表有垂直切分和水平切分两种。
 垂直切分(按照功能模块)-商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等
 水平切分(按照规则划分存储)
  当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行
  划分，然后存储到多个结构相同的表，和不同的库上。
 19.1.11. 两阶段ᨀ交协议
  二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者
  的反馈情报决定各参与者是否要提交操作还是中止操作。
  19.1.11.1. 准备阶段-预提交，发送预结果给到协调组
  19.1.11.2. ᨀ交阶段- 协调组根据预提交结果，发送提交或者回滚给到每个参与者
  19.1.11.3. 缺点：同步阻塞问题 单点故障-协调者 数据不一致（脑裂问题）
   二阶段无法解决的问题（数据状态不确定）
    协调者发送了提交消息后宕机了，唯一收到这条消息的参与者也宕机了，新的协调者也无法知道这条事务是否已提交
19.1.12. 三阶段ᨀ交协议
 跟二阶段提交的区别：1：引入超时机制 2：把准备阶段一分为二
 协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。
 后面的就是二阶段提交了
19.1.13. 柔性事务
 CAP（一致性、可用性、分区容忍性）
 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。
 通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。
 两阶段型-二阶段提交
 补偿型-tcc：a提交，b提交，a失败了，b做反操作恢复状态
 异步确保型：同步事务-采用消息操作
 最大努力通知型（多次尝试）：这是分布式事务中要求最低的一种, 也可以通过消息中间件实现，达到最大重试次数后正常结束
一致性算法：
  Paxos：Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致
  Paxos 三种角色：Proposer，Acceptor，Learners
  Proposer:发起提案-过半就认为被选定
  Acceptor：接收提案
  Learner：被告知哪个提案被选定
  
 Paxos 算法分为两个阶段。具体如下：
  阶段一（准 leader 确定 ）：发起提案， Acceptor接收提案
  阶段二（leader 确认）：接收 Acceptor 反馈，确认提案
20.1.2. Zab：ZAB( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议）
 两种基本模式：奔溃恢复，消息广播-选举新ldear，数据同步，广播出去
20.1.3. Raft
 raft 把算法流程分为三个子问题：选举，日志复制，安全性
 Raft 把集群中的节点分为三种状态：Leader、 Follower 、Candidate，从follower变来，发起选举，成功变成leader
20.1.4. NWR
 N：在分布式存储系统中，有多少份备份数据
 W：代表一次成功的更新操作要求至少有 w 份数据写入成功
 R： 代表一次成功的读数据操作要求至少有 R 份数据成功读取
20.1.5. Gossip
 Gossip 算法又被称为反熵（Anti-Entropy）-经过一番杂乱无章的通信，最终所有节点的状态都会达成一致
20.1.6. 一致性 Hash
  一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。
  20.1.6.1. 一致性 Hash 特性-平衡性，单调性，平滑性
20.1.6.2. 一致性 Hash 原理
  1.建构环形 hash 空间：32位圆环空间
  2.把需要缓存的内容(对象)映射到 hash 空间
  3.把服务器(节点)映射到 hash 空间
  4.把对象映射到服务节点
总结：就是单纯的哈希取模，服务器变动模变了，所以使用圆形，服务器分布在圆形上，哈希取模后在最近的服务器上取值，同时注意服务器分布不均问题

21. JAVA 算法：
 21.1.1. 二分查找
 21.1.2. 冒泡排序算法
 21.1.3. 插入排序算法
 21.1.4. 快速排序算法。。。。
24. 分布式缓存 
 缓存雪崩-大量key同时过期
 缓存穿透-不存在的key，数据库也没有，每次都去查数据库-布隆，或者给特定value
 缓存预热-先把数据加到缓存，不用第一次就去查数据库
 缓存降级-访问剧增时候，牺牲非核心业务缓存
25. Hadoop
 就是一个大数据解决方案。它提供了一套分布式系统基础架构。 核心内容包含 hdfs 和
mapreduce。hadoop2.0 以后引入 yarn.
 
  