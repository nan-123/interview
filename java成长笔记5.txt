java成长笔记5
 19. 数据库
  19.1.1. 存储引擎
 19.1.1.2. InnoDB（B+树）
  InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，
  一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。
 适用场景：
1）经常更新的表，适合处理多重并发的更新请求。
2）支持事务。
3）可以从灾难中恢复（通过 bin-log 日志等）。
4）外键约束。只有他支持外键。
5）支持自动增加列属性 auto_increment。

 19.1.1.3. TokuDB（Fractal Tree-节点带数据）
   TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree
  中，每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个
  Message Buffer 是一个 FIFO 的队列，用来缓存更新操作
 
  例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶
 子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中
 TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优
势。 他主要适用于访问频率不高的数据或历史数据归档

 19.1.1.4. MyIASM
   MyIASM是 MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，
  因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。
  ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。在设计之初就预想数据组织
  成有固定长度的记录，按顺序存储的。---ISAM 是一种静态索引结构。
 19.1.1.5. Memory
   Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应
 一个磁盘文件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用
 HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉
  Memory 同时支持散列索引和 B 树索
 引，B树索引可以使用部分查询和通配查询，也可以使用<,>和>=等操作符方便数据挖掘，散列索
 引相等的比较快但是对于范围的比较慢很多
 19.1.2. 索引
  索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二
 叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree）
19.1.2.1. 常见索引原则有
 1.选择唯一性索引
  1．唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。
  2.为经常需要排序、分组和联合操作的字段建立索引：
  3．为常作为查询条件的字段建立索引。 
  4．限制索引的数目：越多的索引，会使更新表变得很浪费时间
 尽量使用数据量少的索引
 6．如果索引的值很长，那么查询的速度会受到影响。
 6．如果索引的值很长，那么查询的速度会受到影响。
 尽量使用前缀来索引
 7．如果索引字段的值很长，最好使用值的前缀来索引
 7．删除不再使用或者很少使用的索引
 8 . 最左前缀匹配原则，非常重要的原则。
 10 . 尽量选择区分度高的列作为索引
 区分度的公式是表示字段不重复的比例
 11 .索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。
 12 .尽量的扩展索引，不要新建索引。
 19.1.3. 数据库三范式
 19.1.3.1. 第一范式(1st NF －列都是不可再分)
 19.1.3.2. 第二范式(2nd NF－每个表只描述一件事情)
 19.1.3.3. 第三范式(3rd NF－ 不存在对非主键列的传递依赖)
19.1.4. 数据库是事务
 事务是一个不可分割的工作逻辑单元-ACID
 原子性（Atomicity）一致性（Consistency）隔离性（Isolation）永久性（Durability）
 19.1.5. 存储过程(特定功能的 SQL 语句集)
 一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次
 编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过
 程是数据库中的一个重要对象
19.1.6. 触发器(一段能自动执行的程序)
 触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：
 触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统
 会自动调用执行该表上对应的触发器
19.1.7. 数据库并发策略
 并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳
19.1.7.1. 乐观锁
 乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自
 己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间
 戳就是不加锁，通过时间戳来控制并发出现的问题。
19.1.7.2. 悲观锁
 悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加
 锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数
 据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允
 许其他用户访问那部分数据。
19.1.7.3. 时间戳
  时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字
 段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数
 据库的值大的话，就允许保存，否则不允许保存-大大提高数据库处理的并发量
19.1.8. 数据库锁
 19.1.8.1. 行级锁-行级锁是一种排他锁，防止其他事务修改此行
  在使用以下语句时，Oracle 会自动应用行级锁：
  1. INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];
  2. SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新
  3. 使用 COMMIT 或 ROLLBACK 语句释放锁。
 19.1.8.2. 表级锁
   表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使
  用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁
  （排他锁）。
 19.1.8.1. 页级锁
   页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级
  冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁
 19.1.9. 基于 Redis 分布式锁-获取锁的时候，使用 setnx
 SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1
 若 key 存在，则什么都不做，返回 0
 加锁，锁的 value
 值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添
 加一个超时时间，超过该时间则自动释放锁
 -- 0-别人正在使用，1-获取到锁，设置过期时间，uuid判断是否该锁
19.1.10. 分区分表
 
 