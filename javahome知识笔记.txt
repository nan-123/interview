javahome知识笔记
1：volatile的用法
 volatile关键字是Java虚拟机提供的的最轻量级的同步机制，它作为一个修饰符出现，用来修饰变量，但是这里不包括局部变量
 保证变量对所有线程可见
 禁止指令重排
 不保证原子性
 
 并发编程的3个特性（原子性、可见性、有序性）
  volatile和synchronized的区别？

volatile修饰的是变量，synchronized一般修饰代码块或者方法
volatile保证可见性、禁止指令重排，但是不保证原子性；synchronized可以保证原子性
volatile不会造成线程阻塞，synchronized可能会造成线程的阻塞

------------------------------------------------------------------------------------------
代码中如果if-else比较多，阅读起来比较困难，维护起来也比较困难，很容易出bug，接下来，本文将介绍优化if-else代码的八种方案。
### 优化方案一：提前return，去除不必要的else
### 优化方案二：使用条件三目运算符
### 优化方案三：使用枚举
### 优化方案四：合并条件表达式
### 优化方案五：使用 Optional
### 优化方案六：表驱动法
### 优化方案七：优化逻辑结构，让正常流程走主干
### 优化方案八：策略模式+工厂方法消除if else








---------------------------------------------------------------------------------------------------------------------------
线程池参数：7个
corePoolSize 线程池核心线程大小
maximumPoolSize 线程池最大线程数量
keepAliveTime 空闲线程存活时间
unit 空间线程存活时间单位
workQueue 工作队列
threadFactory 线程工厂
handler 拒绝策略
 CallerRunsPolicy 在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务
 AbortPolicy 直接丢弃任务，并抛出RejectedExecutionException异常。
 DiscardPolicy 直接丢弃任务，什么都不做
 DiscardOldestPolicy 抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列
 
线程池的作用
  减少资源的开销 提高了响应速度。 提高线程的可管理性
原理：
 线程池一般由两种角色构成：多个工作线程 和 一个阻塞队列。
工作线程 :
工作线程是一组已经处在运行中的线程，它们不断地向阻塞队列中领取任务执行。

阻塞队列 :
阻塞队列用于存储工作线程来不及处理的任务。当工作线程都在执行任务时，到来的新任务就只能暂时在阻塞队列中存储。

EPOLL基本概念及数据结构
 epoll是一种机制，来处理大量并发连接时事件的读写顺序
 epoll是Linux内核为处理大批量句柄而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本
 epoll_create:创建内核事件表用来存放描述符和事件。它的数据结构为：struct eventpoll。其中包括了两个重要成员，一个是红黑树，也就是内核事件表。另一个重要成员是用于存放就绪事件的队列。
 epoll_ctl:红黑树添加节点操作：ep_insert。红黑树移除节点操作：ep_remove。红黑树修改节点操作：ep_modify。每个节点都是一个描述符和事件的结构体。
 epoll_wait：负责收集就绪事件。
 
 
 HashMap底层数据结构
  JDK1.7及之前：数组+链表
  JDK1.8：数组+链表+红黑树
  数组的长度必须是2的指数次幂 加载因子要设置为0.75  链表长度大于等于8时转成了红黑树
  
redis数据结构及场景使用
 string 存储字符串，数字。。
 hash 存对象
 list：做队列
 set：唯一性，做交集，查询共同好友，做标签
 sortes-set：有序集合 排行榜，带权重的消息队列
 