腾讯音乐
 链表翻转
 1：递归，是最后一个就返回，不是就继续调
 2：遍历，设置临时节点，当前节点，前一个节点，通过while循环，不断交互位置，把tem是当前节点的下一个，cur设置成tem，pre设置成cur
 3：用栈先进后出的特点
 
 三次握手：
  用来建立连接的
  客户端a  服务端b
  a先给b发送请求报文，标记位sync=1，ack=0 初始化序号seq=i(0),进入sync_send状态-同步已发送
  b收到请求报文，如果同意建立连接，向a发送确认报文，syn=1，ack=1，确认号ack=i+1，也初始化一个序号seq=k（0），进入syn_rcvd-同步接收
  a接收到b的确认后，还需要给b发送确认报文，这时，tcp已连接，客户端进入established状态
  
 流控和拥塞控制
  流量控制：滑动窗口，接收方在返回的数据包中包含自己的接收窗口大小
  拥塞控制：防止过多的数据注入到网络中
  流量控制是为了预防拥塞
  拥塞控制方法：出现拥塞，拥塞窗口减小，以减少网络中的分组数，等拥塞过了再加大-慢开始+拥塞避免
                快重传+快恢复，3个重传确认就立刻重传
 vector和list：
    1）vector底层实现是数组；list是双向 链表。

    2）vector支持随机访问，list不支持。

    3）vector是顺序内存，list不是。

    4）vector在中间节点进行插入删除会导致内存拷贝，list不会。

    5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。

    6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。
 strcpy和memcpy的区别
short 2个字节
int 4个字节
long 8个字节

在浏览器中输入网址发生了什么事情
   1.DNS解析 - 域名解析成ip

    2. TCP连接 - 三次握手建立连接

    3.发送HTTP请求

    4.服务器处理请求并返回HTTP报文

    5.浏览器解析渲染页面

    6.断开tcp连接  4次挥手
 	
	发送HTTP请求：
	 请求行：方法+地址+http版本
	        Method Request-URL HTTP-Version CRLF
			请求头是指在客户端向服务器传递请求的附加信息和客户端自身的信息
			常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。常见有Accept Accept-Charset Conent-Type Authorization
            请求体   
			服务器端接到http请求后在会作出响应，响应内容包括：

            响应行：http版本+状态码+状态描述
            响应头
            响应体
			
Java提供的四种线程池的好处在于：
降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

提高响应速度：当任务到达时，可以不需要等待线程创建就能立即执行。

提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，监控和调优。

TCP在建立连接过程中会交换哪些信息
 Windows size（滑动窗口） MSS（最大报文长度）WS（窗口因子 window scale） SACK_PERM
 
TCP和UDP应用场景
 tcp是面向连接的协议   UDP是一个非连接的协议
 TCP协议适用于对效率要求相对低，但对准确性要求相对高的场景下，或者是有一种连接概念的场景下；而UDP协议适用于对效率要求相对高，对准确性要求相对低的场景
 TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；

  UDP一般用于即时通信，在线视频，网络语音电话
TCP和UDP中传输效率受哪些
  服务器网卡处理bai能力
  服务器到客户端之间带du宽瓶颈（由最低zhi带宽决定）
  客户端接收dao能力限制
  UDP程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段
红黑树和平衡树哪个查找元素的效率高
 二叉查找树因可能退化成链表，故其性能最差。平衡二叉树和红黑树是带有平衡条件的二叉查找树，故它们的效率也较高。

  平衡二叉树的插入/删除操作带来的旋转操作可能会达到logn次，而红黑树的插入/删除操作带来的旋转操作最多为2/3次。

  所以说，当红黑树出现的时候，平衡二叉树就只能出现在博物馆里了。即红黑树是最优选择
  红黑树高，但最好还是b+树
hash冲突：
 链表法和开放寻址法
 在哈希表中，每一个桶（bucket）或者槽（slot）都会对应一条链表，所有哈希值相同的元素放到相同槽位对应的链表中。
 如果出现散列冲突，我们就重新探测一个空闲位置，再将元素插入
 再散列
提供多个hash函数，冲突时使用其他的hash函数再次运算
建立公共溢出区
建立一个溢出表，hash冲突的时候放入溢出表

1亿个数字求前100个
 1：排序
 2：局部淘汰-保存前100个，后面的跟前面的比较
 3：分治：将1亿个数据分成100万份，每份100个数据 ，找出每份里面最大的，再排序
 4：第四种方法是Hash法 过滤重复的再排序
 5：第五种方法采用最小堆 前100个建立大小为100的堆，遍历后续的数字，并于堆顶（最小）数字进行比较 如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止
 
 RabbitMQ 怎么做高可用
  镜像集群模式
  跟普通集群模式不一样的是，在镜像集群模式下，无论队列中的元数据还是消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 队列的一个完整镜像。然后每次写消息到队列的时候，都会自动把消息同步到多个实例上

如何开启镜像集群

首先镜像集群是在普通集群的基础上的，所以你要先搭建一个普通集群，然后在随意一个实例上执行如下命令创建一个策略即可开启
rabbitmqctl set_policy -p vhostName name “^xxqueue” '{“ha-mode”:“all”}'
name是策略的名字

xxqueue是需要匹配的队列名称，如果要匹配所有的话使用^

5. Linux 内存 cache 和 buffer 的区别
  Cache：缓存区，是高速缓存  为了提高cpu和内存之间的数据交换速度而设计的
  Buffer：缓冲区，用于存储速度不同步的设备或优先级不同的设备之间传输数据 buffer（缓冲）是为了提高内存和硬盘（或其他I/O设备）之间的数据交换的速度而设计的
 
 
 SWAP的作用类似Windows系统下的“虚拟内存”
 在空间合适处创建swap文件   激活swap文件

大量的请求导致服务器响应很慢, 如何排查, 如何解决
 1：检查网络，ping 
 2：查看资源，cpu，内存，磁盘
 3：看线程池配置
 4：看下是否存在boss攻击-加入黑名单
nginx 用作 web server，如何处理大量连接
 配置静态资源，负载均衡
百丽瓶颈：硬件，
TIME_WAIT状态的作用
　　主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度
  可靠地实现了TCP全双工连接的终止
  当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃
  
什么是堆，有什么作用，一般用在什么场景下使用
什么是二叉树，满二叉树，完全二叉树
 二叉树是一种树型结构，它的特点是每个结点至多只有两颗子树
 一颗深度为k且有2^k - 1 个结点的二叉树成为满二叉树  即每一层都是满满的 
 不是满的 满二叉树  但是缺省部分必须是 从最深处最右边开始往左边缺省
 
时间复杂度怎么计算的
 找出算法中的基本语句； 计算基本语句的执行次数的数量级；用大Ο记号表示算法的时间性能。
稳定排序，快排怎么能让他变成稳定排序
 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法
 快速排序变为冒泡排序
 
进程是资源分配的单位
线程是操作系统调度的单位
进程切换需要的资源很最大，效率很低
线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）
协程切换任务资源很小，效率高
多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以只能是并发
 
 
 进程 线程通信方式
  进程：管道，队列 共享存储 信号量 套接字 信号
  线程：锁机制，信号量，信号
  
让你估算一棵树上有多少叶子要咋估算
 1：冬天去
 2：
http2.0比1.1改进了哪些
 多路复用  二进制分帧层  减少了网络延迟 采用二进制格式传输数据，而非http1.1文本格式  对消息头采用Hpack进行压缩传输
 Server Push
 
惊群是什么
 多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”
 ）频繁地做无效的调度、上下文切换-消耗cpu
  Accept
  ，具体来讲就是当有新的连接进入到accept队列的时候，内核唤醒且仅唤醒一个进程来处理，这是通过以下的代码来实现的：

    list_for_each_entry_safe(curr, next, &q->task_list, task_list) {        unsigned flags = curr->flags;        if (curr->func(curr, mode, wake_flags, key) &&                (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)            break;    }

  是的，添加了一个WQ_FLAG_EXCLUSIVE标记，告诉内核进行排他性的唤醒，即唤醒一个进程后即退出唤醒的过程
 core文件
  Coredump 在unix 平台是非常容易出现的一种错误形式，直接表现形式为core 文件， core 文件产生于当前目录下，
通常，象内存地址错误、非法指令、总线错误等会引起coredump ，core 文件的内容包含进程出现异常时的错误影
像。如果错误进程为多线程并且core 文件的大小受限于ulimit 的系统限制，则系统只将数据区中错误线程的堆栈区
复制到core 文件中。
 https://blog.csdn.net/gftygff/article/details/87349099
 我们可以简单的分析产生core 文件的应用、信号量及进程等信息，如果要求一
些更详细的信息，可以借助于dbx 等调试工具进一步分析

设计一个方案，找出链接在家庭网络中的设备
 监控工具
 
做一个优先级队列，数字越小的优先级越高
 最小堆  堆排序
 
 传入一个列表，一个target，找到两个数相加等于这个target
 遍历。先取第一个，然后把第二个数跟第一个相加，等于就保存起来。然后继续、*方法一:暴力法:
 
第一遍遍历：将（target-a）和i 作为键值对，存入Hash表,遍历时间复杂度为O(n)，
第二遍遍历：查询在Hash表中有和当前数相同的key，每次查询时间复杂度为O(1)，遍历时间复杂度为O(n)，
总的时间复杂度是O(2n)。
 怎么判断5个人是否连接同一个WIFI
  1：ping无线ip
  2：发送广播
  
发5次数据，tcp和udp分别收几次，数据流和数据报
 
 6、堆栈溢出问题
  在一个算法中，如果递归函数调用过多次数，那么就会导致堆栈溢出。
  原因就是，操作系统会自动给每个进程分配一个最大栈空间2M，如果超过了这个上限，就会导致递归函数执行终止，所以就会报错。递归就像你一直在往一个空间里放东西，也就是一直在入栈，调用一次会把内存地址进行一次入栈，直到调用结束，才会将地址出栈。想一想，是不是如果调用次数过多，入栈的内存地址大于2M，就会引起程序报错呢？

同样的，如果你创建一个数组过大，会引起堆溢出，操作系统给每个进程分配的最大堆空间是4G，如果过大会导致堆溢出
尾递归就是在函数返回return时调用函数本身，而不使用其他表达式。这样执行的时候尾递归函数只会占用一个栈帧，就不会引起栈溢出。

4、进程线程的堆栈最大多少
 没有具体最大值，需要设置
 堆≈物理内存-1GB
 栈通常为4MB
 
一个青蛙，每次可以跳一步或者2步，跳到100步，如何做，用什么思路去解
 思路：对于第n阶，只能从n-1或者n-2阶跳上来，故只能是这两种，对于第n-1阶，又只能从n-2或者n-3阶跳上来，故用一个递归，
 直到第二阶或第一阶，实现代码如下  10 - > 89种， 20 - > 1w多种， 30- > 百万
 public static int solution(int stageNum)
     {
         //定义递归出口
         if(stageNum <= 0)
             return 0;
         else if(1 == stageNum)
             return 1;
         else if(2 == stageNum)
             return 2;

         return solution(stageNum - 1) + solution(stageNum - 2);
     }