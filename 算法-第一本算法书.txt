算法-第一本算法书
什么是算法-程序如果是一份菜，那算法就是一份食谱
 算法的步骤是数学方式来描述的，是严谨的
 不同的算法运行时间有很大的差异
 如何求得运行时间：
  步数 ，通过测试总走了多少步来表示时间，因为计算机性能问题，不能准确直接用时间来表示
  o（n）和o（1） 
  表示：当复杂度增加时，时间n3次方增长 。。
  
1：数据结构
 数据顺序和位置就是数据结构
 电话本：姓名-号码
 如果是顺序记录，那就插入快，查询慢
 如果是按照姓名记录，那就查询快，插入慢
 比较好解决方案：
 姓的首字母为单独的表来记录，一个字母一张表
 
 链表：linklist，插入快，查询慢，插入快，查询慢
  1：指针 a->b->c  每个数据都有一个指针指向下一个数据的位置
  2：内存 因为有指针，无需连续的存储空间
  3：顺序访问 每次访问都只能从第一个开始一直查询下去 o（n） 插入操作是o（1），插入操作无论数据多少都是改变一下指针位置
  衍生：循环链表，收尾指针对应，双向链表：可以从后往前查 缺点：增加存储开销，插入删除修改需要改变更多的指针
 数组：就是list，不多说明，有序，查询快，插入慢
 
 栈：子弹夹，先进后出，入栈，出栈，不多说明
 
 队列：管道：先进先出，入队，出队 不多说明
 
 哈希表：k-v
  开始如果不用哈希计算，就需要遍历key获取数据位置，查询慢
  采用哈希表计算出key的位置就可以很快得到key的位置了
  插入时如果位置已经被占用，会使用链表追加数据
  查询时先得到key的位置，获取这个位置上的链表，再遍历这个链表上的key获取数据
 堆：
  是一种树形结构
  普通的二叉树，符合左小右大的特点
 二叉查找树：
  1：每个节点最多2个子节点
  2：左小右大
  3：递归，执行修改操作时间也需要修改其他节点使得符合上面2个要求
  当树比较平衡的时候，时间复杂度是：o(logn),如果树很高时候是o(n)
  
------------------------------------------------------------------------------------------
排序算法
 冒泡排序
  从右边开始，2个2个比较，大的放后面，经过n轮这样的操作，最后达到平衡，时间复杂度为o(n^2)
 选择排序
  选择最小的数放最左边，在剩下的数字里继续这样的操作，直到排序好小-大 时间复杂度为o(n^2)
 插入排序
  从右边一个个的获取数据插入左边已经排好的里面，左边遵守小-大原则移动位置 时间复杂度为o(n^2)
 堆排序
  从堆里取出数据排序，每次取完堆重新构建树，依次从右往左排序就可以
 归并排序
  先把数据一次次分组，直到不能再分为止，就是一个队列一个数据
  然后一次次把每个数据首数据进行合并，左小右大组成一个新的数组
 快速排序
  先在数组中选择一个基准数，随机的，把剩下的数重新分割成2个数组，左边的比基准小，右边的比基准大
  继续在左边和右边的数组中选择基准数重复上面的操作
  总共会分成log2n行
------------------------------------------------------------------------------------------
第三章，数组的查找
 线性查找
  就是从左向右一直查找，可以不需要排序好，时间复杂度：o(n)
 二分查找
  需要先排序好，然后把需要查询的数据跟中间的数做比较，比中间小的在左边继续用相同的方法查，比中间大的在右边查
------------------------------------------------------------------------------------------
第四章：图的搜索
 什么是图？
  类似于人际关系图，每一个数据是一个顶点（节点）
 加权图：
  给每个顶点的边加权，表示两个点的数据连接程度，这个程度表示的意思根据图的不同意义不同，例如可以是网络连接时间
 有向图
  边有箭头的，表示只能单边走向，不能往回走
 4-2广度优先搜索
  是一种图的搜索，假设现在处于某一个点，要查询某一个点，把附近的点作为后补点，优先在候补点搜索要
  查询的点是否在里面，如果不在继续上面查找，类似于遍历查询，优先级是从上到下的节点
 深度优先搜索
  跟上面一样，优先级是顺着一个节点一直往下查找
 贝尔曼-福特算法
  是一种在图中求解最短路径问题的算法，前提是加权图
  假设起点权重是0，其他点权重是无穷大
  从起点开始，尝试走候补边（相邻边），如果边的权重比顶点的权重小，则更新点权重信息，直到所有点权重不能更新为止，这个时候就很
  容易看出从起点到终点哪条路径的权重小了
 狄克斯特拉算法
  也是一种图形算法，选择好开始顶点后，尝试相邻的候补点，顺着权重小的候补点继续前行，直到终点，比贝尔曼要好一些
4-6：A*算法
   A-STAR 算法 
   是上面算法的一种演变，特点是预先预估一个值，省去无用的计算，但前提是预估的值得合理，不然有可能搜不到结果
------------------------------------------------------------------------------------------
第五章-安全算法
 网络传输是可能遇到的问题：窃听，假冒，篡改，事后否认
 窃听-加密处理
 假冒-签名
 篡改-签名
 事后否认-签名
加密：
 哈希函数
  16进制，相当于搅拌机，输出无规律的数字
  特征-不管数据长度，哈希结果长度是固定的，相同的数据哈希值一样
  相似的数据哈希值也会差别很大，不同的数据有可能出现相同的哈希值-哈希冲突（几率很低）
  不可逆 计算容易
  这个算法常用代表：md5 sha-1 sha-2 前两种有安全隐患
 共享秘钥加密
  a b 使用相同的秘钥加密解密，a需要将秘钥先给到b，这样一来有可能秘钥也会被窃取
 公开秘钥加密
  由b先生成公私钥，公钥给到a，私钥自己保存，a给b传输数据的时候用公钥加密，b然后再用私钥解密
  但也存在问题，如果c提前把公钥给到a，a发送数据的时候使用了c的公钥，然后获取数据用自己的私钥解密
 混合加密
  存在一个共享秘钥，b先生成公私钥，然后把公钥给a，a使用共享秘钥加密公开秘钥，再发送给b，b再使用私钥进行解密，这样就可以保护到共享秘钥了
 迪菲-赫尔曼秘钥交换
  是一种把秘钥结合交互的算法，不能分解
 消息认证码
  防止消息被篡改
  a生成一对用于生成消息验证码的秘钥，把秘钥用安全方式给到b，a发送消息的时候把消息验证码也给到b，b收到消息
  后先进行消息认证码校验，一致就是没被篡改，不一致就抛弃重新请求
 数字签名
  a使用共享加密生成签名跟数据一起发送给b，b收到消息后也使用共享秘钥确认签名是否由a生成
  数字签名是a生成公私钥，公钥给到b，私钥自己保存，使用私钥生成签名，b使用公钥确认签名是否是a产生的
  实际使用是使用哈希值，消息的哈希值再加密作为签名
 数字证书
  a生成公私钥，先到第三方机构生成证书，然后把公钥和证书给到b，b校验证书
------------------------------------------------------------------------------------------
第六章：聚类
 什么是聚类：将相似的数据分为一组，每一组叫簇
 k-means算法
  先定好需要分多少簇，随机去簇数的点数作为中心点，，计算附近的点的距离决定归属哪个簇
  但因为中心点是随机的，可能出现强行分簇的情况
------------------------------------------------------------------------------------------
其他算法
 欧几里得：求两个数最大公约数的方法
 素性测试：判断一个数是否素数，从除以2开始求余数，一直到自身开方数，性能比较低
 费马测试：是判断某个数是否素数的概率的，根据费马定理：n的k次方（k>n）除以k，余数等于n
   但也存在伪素数的干扰，所以只能用来做概率判断
 网页排名：
  奇佩排名
   把网页分权重，权重最高约有价值，排名越高，浏览次数越多权重越高，如果是跳转过来的把整个跳转连权重设置为1，在整个跳转里面再分配
  汉诺塔
   属于递归，是一个叠轮盘游戏，底下最大，上面最小，结论：最短时间：n个轮盘：T(N)=2的n次方-1
 
 
   
 
 
  
 