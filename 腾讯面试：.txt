腾讯面试：
Java 基础 
1.进程和线程的区别；
 1 进程是资源分配最小单位，线程是程序执行的最小单位；
 2 进程有自己独立的地址空间 线程没有
 3 CPU切换一个线程比切换进程花费小
 4 创建一个线程比进程开销小
 5 线程占用的资源要比进程少很多
 6 线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行
 7 进程之间相互影响小，进程之间相互影响比较大
 
2.Java 的并发、多线程、线程模型；
 
 
 
 jvm
 1.方法区（Method Area）
2.堆区（Heap）
3.虚拟机栈（VM Stack）
4.本地方法栈（Native Method Stack）
5.程序计数器（Program Counter Register）

经典的引用计数算法，每个对象添加到引用计数器，每被引用一次，计数器+1，失去引用，计数器-1，当计数器在一段时间内为0时，即认为该对象可以被回收了

在JDK1.2之后引入了四个概念：强引用、软引用、弱引用、虚引用

 内存主要被分为三块：新生代（Youn Generation）、旧生代（Old Generation）、持久代（Permanent Generation）。三代的特点不同，造就了他们使用的GC算法不同，新生代适合生命周期较短，快速创建和销毁的对象，
 旧生代适合生命周期较长的对象，
 持久代在Sun Hotpot虚拟机中就是指方法区（有些JVM根本就没有持久代这一说法）。
 复制、标记-清除  标记-压缩
   串行收集器（Serial GC）
   Serial GC是最古老也是最基本的收集器，但是现在依然广泛使用，JAVA SE5和JAVA SE6中客户端虚拟机采用的默认配置。比较适合于只有一个处理器的系统。在串行处理器中minor和major GC过程都是用一个线程进行回收的。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world）
   ParNew GC
       基本和Serial GC一样，但本质区别是加入了多线程机制
	   
	   Parallel Scavenge GC
       在整个扫描和复制过程采用多线程的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式。
	   
	    CMS (Concurrent Mark Sweep)收集器
       该收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间。常见的B/S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清楚算法实现的。

CMS收集器的优点：并发收集、低停顿，但远没有达到完美；

 G1收集器
       相比CMS收集器有不少改进，首先，基于标记-压缩算法，不会产生内存碎片，其次可以比较精确的控制停顿。

4.6 Serial Old收集器
       Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。

4.7 Parallel Old收集器
       Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

4.8 RTSJ垃圾收集器
       RTSJ垃圾收集器，用于Java实时编程
	   
	   ---------------------------------------------------------
.堆和栈在内存中的区别是什么

一、主体不同bai

1、内存堆du：是一个特zhi定的存储区或寄存器，它的dao一端zhuan是固定的，另一端是浮动的。shu

2、栈：是一种运算受限的线性表。

二、特点不同

1、内存堆：允许程序在运行时动态地申请某个大小的内存空间。

2、栈：定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。

三、优势不同

1、内存堆：栈是个特殊的存储区，主要功能是暂时存放数据和地址，用来保护断点和现场。

2、栈：只能在一端进行插入和删除操作的特殊线性表。按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。
 