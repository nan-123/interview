jvm：java代码的假想计算机 包括 【一套字节码指令，寄存器，一个栈，一个垃圾回收，堆，和一个存储方法域】
运行过程：
 源文件-编译器 class文件，也就是字节码文件 - jvm - 机器码
 【当一个程序开始运行，虚拟机就开始实例化】
 运行时数据区：
 方法区，      虚拟机栈 本地方法栈
               程序计数器           这块是线程私有   《-》 类加载器子系统
 堆                  |
  ^
  |                 双向
  V                  |
  即时编译器
  垃圾收集    -》本地库接口 - 》本地方法库
   |
   这块是线程共有
   
 线程：
 hotspot jvm 后台运行的系统线程主要有：
 虚拟机线程
 周期性任务线程
 gc线程
 编译器线程
 信号分发线程
 
 线程共享区域随虚拟机的启动/关闭而创建/销毁
 ~
 2.2.JVM 内存区域
   JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区
   域【JAVA 堆、方法区】、直接内存。
 2.2.1. 程序计数器(线程私有)
  一块较小的内存空间, 是当前线程所执行的字节码的 【行号指示器】
  这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。
  
 2.2.2. 虚拟机栈(线程私有)
  是描述java方法执行的内存模型，【每个方法在执行的同时都会创建一个栈帧】（Stack Frame）
  用于【存储局部变量表、操作数栈、动态链接、方法出口】等信息
  每一个方法从调用直至执行完成
  的过程，就对应着一个栈帧在【虚拟机栈中入栈到出栈的过程】。
  栈帧（ Frame）
  是用来 【存储数据】 和 【部分过程结果】 的数据结构，同时也被用来处理 动态链接
 (Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着【方法】调用而创
 
 2.2.3. 本地方法区(线程私有)
  本地方法区和 Java Stack 作用类似, 区别是【虚拟机栈为执行 Java 方法服务】, 而本地方法栈则为
 【 Native 方法服务】, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个
  C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。
 
 2.2.4. 堆（Heap-线程共享）-运行时数据区
  是被线程【共享的一块内存区域】，【创建的对象和数组都保存在 Java 堆内存中】，也是【垃圾收集器进行
 垃圾收集的最重要的内存区域】。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以
 细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。
 
 2.2.5. 方法区/永久代（线程共享）
  即我们常说的【永久代(Permanent Generation)】, 用于存储被【 JVM 加载的类信息、常量、静
  态变量、即时编译器编译后的代码】等数据
  永久带的内存回收的主要目标是针对常量池的回收和类型
  的卸载
   【运行时常量池（Runtime Constant Pool）是方法区的一部分【。Class 文件中除了有【类的版
   本、字段、方法、接口】等描述等信息外，还有一项信息是常量池 用于存放编译期生成的各种字面量和符号引用
  ~
  2.3.JVM 运行时内存
   Java 堆从 【GC 的角度】还可以细分为: 【新生代(Eden 区】、From Survivor 区和 To Survivor 区)和【老年代。】
   2.3.1. 新生代
    是用来存放【新生的对象】。一般占据【堆的 1/3 空间】。由于频繁创建对象，所以新生代会【频繁触发
   MinorGC 进行垃圾回收】。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。
   
   2.3.1.1. Eden 区
   Java 【新对象的出生地】（如果新创建的对象占用内存很大，则直接分配到老
   年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行
  一次垃圾回收。
  2.3.1.2. ServivorFrom
  上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
  2 .3.1.3. ServivorTo
  保留了一次 MinorGC 过程中的幸存者。
  MinorGC 采用复制算法
  1 eden、servicorFrom 复制到 ServicorTo，年龄+1 （如果有对象的年
  龄以及达到了老年的标准，则赋值到老年代区
  2：清空 eden、servicorFrom
  3：ServicorTo 和 ServicorFrom 互换
  2.3.2. 老年代
  无法找到足
 够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间
 MajorGC 采用标记清除算法
  2.3.3. 永久代
  指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息
 ,GC 不会在主程序运行期对永久区域进行清理。所以这
  也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常
   Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代
 ~ 
  2.4.垃圾回收与算法
  
   gc要做三件事：哪些内存需要回收；什么时候回收，怎么回收
   哪些对象已经死亡：
   引用计数器
   gc roots tracing 
    通过cg roots的点作为起点，向下搜索，当一个对象没有任何的引用链相连，就说明死亡
	gc roots：vm栈中的引用；方法区中的静态引用jni中的引用
  垃圾收集器算法：标记清除，复制，标记整理，分代收集
  垃圾收集器：
   serial； parnew； paraller scavenge； serial old；parallel old； cms
   
   参数：xms xmx xmn
   
  2.4.1.1. 引用计数法
	个对象如果没有任何与之关
   联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收
   对象
  2.4.1.2. 可达性分析 - 的循环引用问题，
  通过一系列的“GC roots”
  对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的
  不可达对象变为可回收对象至少要经过两次标记
  过程
  2.4.2. 标记清除算法（Mark-Sweep） 法最大的问题是内存碎片化严重 
  2.4.3. 复制算法（copying）实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原
   本的一半
  2.4.4. 标记整理算法(Mark-Compact)
   标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象
  2.4.5. 分代收集算法
   分代收集法是目前大部分 JVM 所采用的方法  老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃
   圾回收时都有大量垃圾需要被回收
  2.4.5.1. 新生代与复制算法
   目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法
  2.4.5.2. 老年代与标记复制算法
   而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。
  当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被
  移到老生代中。
 ~
  2.5.JAVA 四中引用类型
    2.5.1. 强引用
	 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引
     用。当一个对象被强引用变量引用时不可能被垃圾回收机制回收的，即
     使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之
     一
	2.5.2. 软引用
	 软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它
     不会被回收 软引用通常用在对内存敏感的程序中。
	2.5.3. 弱引用
	 弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象
     来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存
	2.5.4. 虚引用
	 虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚
     引用的主要作用是跟踪对象被垃圾回收的状态
	 ~
 2.6.GC 分代收集算法 VS 分区收集算法
  2.6.1. 分代收集算法
  当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据
   对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据
   各年代特点分别采用最适当的 GC 算法  
  2.6.2. 分区收集算法
   分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的
   好处是可以控制一次回收多少个小区间
 ~
 2.7.GC 垃圾收集器
   Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；
   年老代主要使用标记-整理垃圾回收算法
   
  2.7.1. Serial 垃圾收集器（单线程、复制算法）
  2.7.2. ParNew 垃圾收集器（Serial+多线程）
   ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限
   制垃圾收集器的线程数。【Parallel：平行的】
  2.7.3. Parallel Scavenge 收集器（多线程复制算法、高效） 它重点关注的是程序达到一个可控制的吞吐量
  2.7.4. Serial Old 收集器（单线程标记整理算法 ）
  2.7.5. Parallel Old 收集器（多线程标记整理算法）在 JDK1.6
  才开始提供。
  2.7.6. CMS 收集器（多线程标记清除算法）种年老代垃圾收集器，其最主要目标是获取最短垃圾
  回收停顿时间
  2.7.7. G1 收集器
  Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收
  集器两个最突出的改进是：
  1. 基于标记-整理算法，不产生内存碎片。
  2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收
  G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域
  ~
 2.8. JAVA IO/NIO
  2.8.1. 阻塞 IO 模型
  2.8.2. 非阻塞 IO 模型
   当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果
   于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就
   绪，这样会导致 CPU 占用率非常高
  2.8.3. 多路复用 IO 模型
   多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO
   模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真
   正调用实际的 IO 读写操作
   多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态
   时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效
   率要比用户线程要高的多
  2.8.4. 信号驱动 IO 模型
   在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函
   数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到
   信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作
  2.8.5. 异步 IO 模型
   异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就
   可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，
   它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block
   
 2.8.1. JAVA IO 包 writer read 流操作包
 ~
2.9.JVM 类加载机制
  JVM 类加载机制分为五个部分：加载- class文件，验证-校验class文件，准备-准备内存，解析-常量池，初始化
  2.9.2. 类加载器
   JVM 提供了 3 种类加载器
  2.9.2.1. 启动类加载器(Bootstrap ClassLoader) 负责加载 JAVA_HOME\lib
  2.9.2.2. 扩展类加载器(Extension ClassLoader) 负责加载 JAVA_HOME\lib\ext
  2.9.2.3. 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库
   JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader
   实现自定义的类加载器
  2.9.3. 双亲委派
   当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
   类去完成 只有当父类加载器反馈自己无法完成这个请求的时候 子类加载器才会尝试自己去加载
   这样就保证了使用不同的类加载
   器最终得到的都是同样一个 Object 对象
 2.9.4. OSGI（动态模型系统）
 ------------------------------------------------------------------------------------------------------
                3. JAVA 集合
 集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。
  1. Collection：Collection 是集合 List、Set、Queue 的最基本的接口。
  2. Iterator：迭代器，可以通过迭代器遍历集合中的数据
  3. Map：是映射表的基础接口
 3.2.List
  分别是 ArrayList、Vector 和 LinkedList。
 3.3.Set
  hashset treeset linkehashset 
 3.4.Map  HashMap（数组+链表+红黑树） 2倍，0.75
 3.4.2. ConcurrentHashMap
  ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一
  些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的
  意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个
  segment。
  3.4.2.2. 线程安全（Segment 继承 ReentrantLock 加锁）
   简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承
   ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每
   个 Segment 是线程安全的，也就实现了全局的线程安全
   默认是 16，
   也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支
   持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时
   候设置为其他值，但是一旦初始化以后，它是不可以扩容的
 3.4.3. HashTable（线程安全）
  3.4.4. TreeMap（可排序）
  3.4.5. LinkHashMap（记录插入顺序）
  --------------------------------------------------------------------------------
       4. JAVA 多线程并发
 4.1.2. JAVA 线程实现/创建方式
  4.1.2.1. 继承 Thread 类 Thread 类本质上是实现了 Runnable 接口的一个实例 start()方法是一个 native 方法，它将启动一个新线
  程，并执行 run()方法
  4.1.2.2. 实现 Runnable 接口
  4.1.2.3. ExecutorService、Callable<Class>、Future 有返回值线程
  4.1.2.4. 基于线程池的方式
 线程状态：
  新建-就绪-运行-死亡
        |-阻塞-|
 4.1.5.3. Interrupt 方法结束线程
 ：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，
会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。
4.1.6. sleep 与 wait 区别
 1. 对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于
  Object 类中的。
  2. sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然
 保持者，当指定的时间到了又会自动恢复运行状态。
 3. 在调用 sleep()方法的过程中，线程不会释放对象锁。
 4. 而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此
  对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。
 
 4.1.7. start 与 run 区别
  1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，
  可以直接继续执行下面的代码。
  2. 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运
  行。
  3. 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运
  行 run 函数当中的代码
 4.1.8. JAVA 后台线程
  1定义：守护线程--也称“服务线程”，他是后台线程，它有一个特性
  2优先级：守护线程的优先级比较低
  3设置：通过 setDaemon(true)来设置线程为“守护线程
  4. 在 Daemon 线程中产生的新线程也是 Daemon 的。
  5. 线程则是 JVM 级别的
  6. example: 垃圾回收线程就是一个经典的守护线程
  7. 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周
    期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依
    赖于系统，与系统“同生共死”
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
4.1.9. JAVA 锁 -锁的分类
   4.1.9.1. 乐观锁
   乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为
   别人不会修改，所以不会上锁 - 的版本号
   4.1.9.2. 悲观锁
   悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人
   会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。
   java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，
   才会转换为悲观锁，如 RetreenLock
  4.1.9.3. 自旋锁 
   自旋锁的开启
  JDK1.6 中-XX:+UseSpinning 开启；
  -XX:PreBlockSpin=10 为自旋次数；
  JDK1.7 后，去掉此参数，由 jvm 控制
 4.1.9.4. Synchronized 同步锁
  synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重
  入锁
   1. 作用于方法时，锁住的是对象的实例(this)；
   2. 当作用于静态方法时，锁住的是Class实例
   3. synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块
   6. Synchronized 是非公平锁
   7. 每个对象都有个 monitor 对象
   8. synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的
   9. Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向
     锁等，效率有了本质上的提高
  10. 锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；
 4.1.9.5. ReentrantLock
   ReentantLock 【继承接口 Lock 】并实现了接口中定义的方法，他是一种可【重入锁】，除了能完
   成 synchronized 所能完成的所有工作外，还提供了诸如可响应【中断锁、可轮询锁请求、定时锁等】
   避免多线程死锁的方法
 Lock 接口的主要方法
     1. void lock():2. boolean tryLock()：3. void unlock()：4. Condition newCondition()：条件对象，获取等待通知组件。
	 13. isLock()：
 非公平锁 
   JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了
   是否公平锁的初始化方式，默认为非公平锁
 公平锁：先请求先得
  ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁
 ReentrantLock 与 synchronized
   1. ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，
   与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。
   2. ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁
 Condition 类和 Object 类锁方法区别区别
  1. Condition 类的 awiat 方法和 Object 类的 wait 方法等效
  2. Condition 类的 signal 方法和 Object 类的 notify 方法等效
  3. Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效
  4. ReentrantLock 类可以唤醒【指定条件】的线程，而 object 的唤醒是随机的快乐
 tryLock 和 lock 和 lockInterruptibly 的区别
  2. lock 能获得锁就返回 true，不能的话一直等待获得锁
  3. lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，
   lock 不会抛出异常，而 lockInterruptibly 会抛出异常。
 4.1.9.6. Semaphore 信号量
  Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信
  号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来
  构建一些对象池，资源池之类的，比如数据库连接池
   通过 acquire()与release()方法来获得和释放临界资源
 4.1.9.7. AtomicInteger
  首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有
   AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等 通常AtomicInteger
  的性能是 ReentantLock 的好几倍。
 4.1.9.8. 可重入锁（递归锁）
  在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。
 4.1.9.10. ReadWriteLock 读写锁
 4.1.9.11. 共享锁和独占锁
 4.1.9.12. 重量级锁（Mutex Lock）
  Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的
 4.1.9.13. 轻量级锁
  锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。
 其他概念：锁升级 偏向锁 分段锁 
 4.1.9.16.锁优化
  减少锁持有时间 减小锁粒度 锁分离 锁粗化 锁消除
4.1.10. 线程基本方法 - 这是使用方法部分
线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等。
 4.1.10.1. 线程等待（wait） 4.1.10.2. 线程睡眠（sleep） 4.1.10.3. 线程让步（yield） 4.1.10.4. 线程中断（interrupt）
 4.1.10.5. Join 等待其他线程终止
  很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果
 4.1.10.7. 线程唤醒（notify）
 4.1.10.8. 其他方法：
   1. sleep()：强迫一个线程睡眠Ｎ毫秒。
   2. isAlive()： 判断一个线程是否存活。
   3. join()： 等待线程终止。
   4. activeCount()： 程序中活跃的线程数。
   5. enumerate()： 枚举程序中的线程。
   6. currentThread()： 得到当前线程。
   7. isDaemon()： 一个线程是否为守护线程。
   8. setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线
   程依赖于主线程结束而结束) 
   9. setName()： 为线程设置一个名称。
   10. wait()： 强迫一个线程等待。
   11. notify()： 通知一个线程继续运行。
   12. setPriority()： 设置一个线程的优先级。
   13. getPriority():：获得一个线程的优先级。
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 4.1.11. 线程上下文切换
  时间片轮转  保存当前任务状态（线程） 继续服务下一个任务，任务的状态保存及再加载, 这段过程就叫做
  上下文切换
 4.1.11.1. 进程
  也称任务
 4.1.11.2. 上下文
  是指某一时间点 【CPU 寄存器和程序计数器】的内容。
 4.1.11.3. 寄存器
  是 CPU 内部的数量较少但是速度很快的内存
 4.1.11.4. 程序计数器
  是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置
 4.1.11.5. PCB-“切换桢”
  上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下
  文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称
  作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。
 4.1.11.6. 上下文切换的活动：
  挂起一个进程 
  在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。
  跳转到程序计数器所指向的位置
 4.1.11.7. 引起线程上下文切换的原因
  当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；
  当前执行任务碰到 IO 阻塞，跳到下一个线程
  没有抢到资源被挂起
  硬件中断
  代码挂起当前线程
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   4.1.12. 同步锁与死锁
 4.1.12.1. 同步锁
  就是排他锁
 4.1.12.2. 死锁
  何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。
 4.1.13. 线程池原理
  线程数量
  将任务放入队列
  线程创建后启动任务
  超过了线程数量就等待
  他的主要特点为：线程复用；控制最大并发数；管理线程
 4.1.13.1. 线程复用
   继承重写hread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象
   循环方法中不断获取 Runnable 是用 Queue 实现的
 4.1.13.2. 线程池的组成
  1. corePoolSize：指定了线程池中的线程数量。
  2. maximumPoolSize：指定了线程池中的最大线程数量。
  3. keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多
  次时间内会被销毁。
  4. unit：keepAliveTime 的单位。
  5. workQueue：任务队列，被提交但尚未被执行的任务。
  6. threadFactory：线程工厂，用于创建线程，一般用默认的即可。
  7. handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。
 4.1.13.3. 拒绝策略
  1. AbortPolicy ： 直接抛出异常，阻止系统正常运行。
  2. CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的
  任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。
  3. DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再
  次提交当前任务。
  4. DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢
  失，这是最好的一种方案。
  以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际
  需要，完全可以自己扩展 RejectedExecutionHandler 接口。
 4.1.13.4. Java 线程池工作过程
  1：创建线程池
  2. 当调用 execute() 方法添加一个任务时，线程池会做如下判断
   a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务
   b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；
   c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要
      创建非核心线程立刻运行这个任务；
   d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池
      会抛出异常 RejectExecutionException。
  3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。
  4. 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运
     行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它
     最终会收缩到 corePoolSize 的大小。
 4.1.14. JAVA 阻塞队列原理
  阻塞队列，关键字是阻塞
  1. 当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放
     入队列。
  2. 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有
     空的位置，线程被自动唤醒
 4.1.14.1. 阻塞队列的主要方法
  1：poll  3：take() 4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象
 4.1.14.2. Java 中的阻塞队列
  1. ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。
  2. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。
  3. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。
  4. DelayQueue：使用优先级队列实现的无界阻塞队列。
  5. SynchronousQueue：不存储元素的阻塞队列。
  6. LinkedTransferQueue：由链表结构组成的无界阻塞队列。
  7. LinkedBlockingDeque：由链表结构组成的双向阻塞队列
 4.1.15.1. CountDownLatch（线程计数器 ）
  比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行
 4.1.15.2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）
  通过它可以实现让一组线程等待至某个状态之后再全部同时执行
 4.1.15.3. Semaphore（信号量-控制同时访问的线程个数）
  通过acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。
 4.1.16. volatile 关键字的作用（变量可见性、禁止重排序）  
 4.1.17. 如何在两个线程之间共享数据
  共享内存主要的关注点有两个：可见性和有序性原子性
  synchronized
 4.1.18. ThreadLocal 作用（线程本地存储）
  ThreadLocal 的作用是提供线程内的局部变量
  ThreadLocalMap（线程的一个属性）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4.1.20. ConcurrentHashMap 并发
  4.1.20.1. 减小锁粒度
 4.1.20.2. ConcurrentHashMap 分段锁
  默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段
  是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁
  ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成
  Segment 是一种可重入锁 ReentrantLock  HashEntry 则用于存储键值对数据
  每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁
 4.1.21. Java 中用到的线程调度
  4.1.21.1. 抢占式调度：在这种机制下，一个线程的堵塞不会导致整个进程堵塞。  4.1.21.2. 协同式调度：运行到一半就一直堵塞，那么可能导致整个系统崩溃。
 4.1.22.1. 优先调度算法
  1. 先来先服务调度算法（FCFS） 4.1.22.2. 高优先权优先调度算法 4.1.22.3. 基于时间片的轮转调度算法
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  4.1.23. 什么是 CAS（比较并交换-乐观锁机制-锁自旋）
   4.1.23.1. 概念及特性
    CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值
    CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作
    CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时
      刻比较并替换，那么在这个时间差类会导致数据的变化。
	  部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题
   4.1.24. 什么是 AQS（抽象的队列同步器）
   
 