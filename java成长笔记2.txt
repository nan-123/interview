java成长笔记2
 5. JAVA 基础
 5.1.1. JAVA 异常分类及处理  内存异常  编译器报错  运行时报错
  5.1.1.2. 异常分类
  Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception
  Error
   Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果
   出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。
  Exception（RuntimeException、CheckedException）
   2. Exception 又有两个分支，一个是运行时异常 RuntimeException ，一个是
      CheckedException
   RuntimeException 如 ： NullPointerException 、 ClassCastException ；一个是检查异常
   CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException 是
   那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一
   定是程序员的错误
  检查异常 CheckedException：一般是外部错误，这种异常都发生在编译阶段
 5.1.1.4. Throw 和 throws 的区别：
 5.1.2. JAVA 反射
  5.1.2.1. 动态语言
    Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；
     并且对于任意一个对象，都能够调用它的任意一个方法
 5.1.2.3. 反射的应用场合
 5.1.2.4. Java 反射 API
  1. 获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。
  2. 调用 Class 类中的方法，既就是反射的使用阶段。
  3. 使用反射 API 来操作这些信息。
 5.1.2.7. 创建对象的两种方法 
  Class 对象的 newInstance()
  调用 Constructor 对象的 newInstance()
  Class clazz=Class.forName("reflection.Person"); 
  //使用.newInstane 方法创建对象
  Person p=(Person) clazz.newInstance();
  //获取构造方法并创建对象
  Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class);
 5.1.3. JAVA 注解
  Annatation(注解)是一个接口
  5.1.3.2. 4 种标准元注解
   @Target 修饰的对象范围 @Retention 定义 被保留的时间长短 @Documented ᧿述-javadoc @Inherited 阐述了某个被标注的类型是被继承的
 5.1.4. JAVA 内部类
  据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。
 5.1.5. JAVA 泛型
  泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数
 5.1.5.1. 泛型方法（<E>）
  T 意味某种类型  
  E 意味 链表、数组里的元素，如List<E> list 表示 list 里的元素。
  K意味map(k,v) 里的键值 Key
  V 意味 返回或映射的值。
 5.1.5.4. 类型擦除
  Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的
 5.1.6. JAVA 序列化(创建可复用的 Java 对象)
-----------------------------------------------------------------------------------------------------
 6. Spring 原理
  6.1.1. Spring 特点
  6.1.1.1. 轻量级  1M多，非入侵-不易了spring的特定类
  6.1.1.2. 控制反转 促进了低耦合 对象依赖被动传递
  6.1.1.3. 面向切面 -业务逻辑和系统服务分开
  6.1.1.4. 容器 spring自动管理对象配置和生命周期
  6.1.1.5. 框架集合 -容易整合其他框架
 6.1.2. Spring 核心组件
  web；data access-jdbc orm等；aop；core contaner - bean，core，context
 2：模块组成
 spring xxx 
        core ：核心库类，ioc
		context 框架式的bean访问
		aop：aop服务
		dao：jdbc处理
		web：面向web综合特性
		mvc：
		orm：对现有orm框架支持
  6.1.5. Spring 常用注解
   controller;restController;component;repository;service
   responsebody;requestMapping;autowired;pathVariable
   modelattrbute;valid;cookieValue
  6.1.7. Spring IOC 原理
   实现：
    1.1..1.1.1 BeanDefinitionRegistry 注册表
	 1. Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，
        它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册
         BeanDefinition 对象的方法。
	 1.1..1.1.2 BeanFactory 顶层接口
	  2. 位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中
         返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：
	 1.1..1.1.3 ListableBeanFactory
	   3. 该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型
          Bean 的配置名、查看容器中是否包括某一 Bean 等方法；
	1.1..1.1.4 HierarchicalBeanFactory 父子级联
       4. 父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过
       HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子
       容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实
       现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久
       层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务
       层和持久层的 Bean 则看不到展现层的 Bean
	1.1..1.1.5 ConfigurableBeanFactory
	 5. 是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容
        器初始化后置处理器等方法；
    1.1..1.1.6 AutowireCapableBeanFactory 自动装配
	 6. 定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；
	1.1..1.1.7 SingletonBeanRegistry 运行期间注册单例 Bean
      7. 定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean 
      来说，BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从
      IoC 容器的缓存中获取 Bean 实例
ApplicationContext 面向开发应用
   ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。
   ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础
  上，还通过多个其他的接口扩展了 BeanFactory 的功能：
  1. ClassPathXmlApplicationContext：默认从类路径加载配置文件
  2. FileSystemXmlApplicationContext：默认从文件系统中装载配置文件
  3. ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事
    件、关闭事件等
  4. MessageSource：为应用提供 i18n 国际化消息访问的功能
  5. ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于
     PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文
     件路径装载 Spring 的配置文件
  6. LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要
     用于控制异步处理过程
  7. ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要
     的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下
     文的能力。
 6.1.7.4. Spring Bean 作用域
  定义了 5 中作用域，分别为 singleton（单例）、prototype（原型）、
    request、session 和 global session
 6.1.7.5. Spring Bean 生命周期
  1 实例化
    实例化一个 Bean，也就是我们常说的 new。
  2 IOC 依赖注入
    按照 Spring 上下文对实例化的 Bean 进行配置，也就是 IOC 注入
  3 setBeanName 实现
    如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String)
   方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值
  4 BeanFactoryAware 实现
    如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory，
      setBeanFactory(BeanFactory)传递的是 Spring 工厂自身
  5 ApplicationContextAware 实现
    如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用
    setApplicationContext(ApplicationContext)方法，传入 Spring 上下文
  6 postProcessBeforeInitialization 接口实现-初始化预处理
   如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用
   postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用
   作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用那个的方法，也可以被应
   用于内存或缓存技术
  7 init-method
    如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法。
  8 postProcessAfterInitialization
   如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用
   postProcessAfterInitialization(Object obj, String s)方法。
   注：以上工作完成以后就可以应用这个 Bean 了
  9 Destroy 过期自动清理阶段
   当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调
   用那个其实现的 destroy()方法
  10 destroy-method 自配置清理
   最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的
   销毁方法
 6.1.7.6. Spring 依赖注入四种方式
  构造器注入
       /*带参数，方便利用构造器进行注入*/ 
      public CatDaoImpl(String message){ 
      this. message = message; 
       } 
     <bean id="CatDaoImpl" class="com.CatDaoImpl"> 
     <constructor-arg value=" message "></constructor-arg> 
     </bean>  
 
 setter 方法注入
       public class Id { 
     private int id; 
     public int getId() { return id; } 
     public void setId(int id) { this.id = id; } 
      
     bean id="id" class="com.id "> <property name="id" value="123"></property> </bean>
  静态工厂注入
  实例工厂
 6.1.7.7. 5 种不同方式的自动装配
     Spring 装配包括手动装配和自动装配，手动装配是有基于 xml 装配、构造方法、setter 方法等
     自动装配有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。
   1. no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。
   2. byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设
    置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。
   3. byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被
    设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多
    个 bean 符合条件，则抛出错误。
   4. constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数
    的构造器参数类型，将会抛出异常。
   5. autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType 方式
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 6.1.8. Spring APO 原理
  AOP 把软件系统分为两个部分：核心关注点和横切关注点
  比如权限认证、日志、事物
  1、切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象
  2、横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。
  3、连接点（joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring
   中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。
  4、切入点（pointcut）：对连接点进行拦截的定义
  5、通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、
   异常、最终、环绕通知五类。 6、目标对象：代理的目标对象
  7、织入（weave）：将切面应用到目标对象并导致代理对象创建的过程
  8、引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法
    或字段
6.1.8.1. AOP 两种代理方式
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 6.1.9. Spring MVC 原理
  Spring 的模型-视图-控制器（MVC）框架是围绕一个 DispatcherServlet 来设计的，这个 Servlet
   会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染
   等，甚至还能支持文件上传
   Http 请求到 DispatcherServlet
     (1) 客户端请求提交到 DispatcherServlet。
  HandlerMapping 寻找处理器
     (2) 由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的
      Controller。
  调用处理器 Controller
     (3) DispatcherServlet 将请求提交到 Controller。
  Controller 调用业务逻辑处理后，返回 ModelAndView
     (4)(5)调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回 ModelAndView。
  DispatcherServlet 查询 ModelAndView
     (6)(7)处理视图映射并返回模型： DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，
       找到 ModelAndView 指定的视图。
  ModelAndView 反馈浏览器 HTTP
     (8) Http 响应：视图负责将结果显示到客户端。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 6.1.10. Spring Boot 原理
  